# -*- coding: utf-8 -*-
"""Renewable energy optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RKkgg21vvvuan2AjO-IAiS2EAhFpgQ_U
"""

import warnings

warnings.filterwarnings('ignore')
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_absolute_error
from sklearn.preprocessing import MinMaxScaler

from flask import Flask, request, jsonify
import joblib
import pickle
import pandas as pd

Energy = pd.read_csv('"I:\Cloudpioneers\Renewable energy optimization\renewable energy production (2).csv"')
Energy



# getting some informations about the dataset
Energy.info()

# statistical Measures of the dataset
Energy.describe()

Energy['Source'].value_counts()

y=Energy ['Source'].value_counts()
labels=['wind','solar']
plt.pie(y,labels=labels,autopct='%1.1f%%')
plt.legend(loc='lower left')
plt.show()

sns.heatmap(Energy.corr(),annot=True)

Energy ['Date'] = pd.to_datetime(Energy ['Date'])
# Extract the year
Energy ['Year'] = Energy ['Date'].dt.year

a1=Energy .groupby('dayName')['Production'].sum().reset_index()
a1

#plotting time series graph of source wind with year, month, day etc
fig = go.Figure([go.Scatter(x=a1['dayName'], y=a1['Production'],line=dict(color='green', width=2))])
fig.update_layout(title='Time Series Graph of daywise production of Electricity using wind',
                  xaxis_title='Days',  # Set the x-axis label
                  yaxis_title='Production')
fig.show()

a2=Energy.groupby('monthName')['Production'].sum().reset_index()
a2

import plotly.graph_objects as go
fig = go.Figure([go.Scatter(x=a2['monthName'], y=a2['Production'],line=dict(color='green', width=2))])
fig.update_layout(title='Time Series Graph of Monthwise production of Electricity using wind',
                  xaxis_title='Months',  # Set the x-axis label
                  yaxis_title='Production')
fig.show()

a3=Energy.groupby('Year')['Production'].sum().reset_index()
a3

#yearwise plotting
import plotly.graph_objects as go
fig = go.Figure([go.Scatter(x=a3['Year'], y=a3['Production'],line=dict(color='green', width=2))])
fig.update_layout(title='Time Series Graph of Yearwise production of Electricity using wind',
                  xaxis_title='Years',  # Set the x-axis label
                  yaxis_title='Production')
fig.show()

"""**Data Cleaning and preprocessing**"""

# Fill missing values with mean
Energy.fillna(Energy.mean(), inplace=True)
Energy

# Droping 'Date and Hour' column
Energy.drop(columns=["Date and Hour"])

Energy.dtypes

# sorting the data based on the date and working hour

Energy = Energy .sort_values(by=["Date","StartHour"])
Energy  = Energy .reindex(list(range(len(Energy))))
Energy .isnull().sum()

null_rows = Energy [Energy .isnull().any(axis=1)]
null_rows

"""**Data Visualization**

1. Yearly Energy Production
"""

Energy ['Date'] = pd.to_datetime(Energy ['Date'])
# Extract the year
Energy ['Year'] = Energy ['Date'].dt.year

# Display the 'Year' column
print(Energy ['Year'])
yearly_production = Energy.groupby(by=["Source","Year"]).Production.sum().reset_index()
yearly_production

import matplotlib.pyplot as plt
import seaborn as sns
Bar_colors = ['blue', 'green', 'red']
plt.figure(figsize=(9, 6))
sns.barplot(data=yearly_production, x="Year", y="Production", hue="Source", palette = Bar_colors)
plt.title("Yearly Production")
plt.xlabel("Year")
plt.ylabel("Production")
plt.show()

sns.set_style("whitegrid")


line_colors = ['blue', 'green', 'red']

plt.figure(figsize=(9, 6))
sns.lineplot(data=yearly_production, x="Year", y="Production", hue="Source", palette=line_colors)

plt.title("Yearly Production")
plt.xlabel("Year")
plt.ylabel("Production")
plt.show()



"""2. Monthly Energy Production in Every Year"""

month_order = {"JEnergy nuEnergy ry": 1, "FebruEnergy ry": 2, "MEnergy rch": 3, "Energy pril": 4, "MEnergy y": 5, "June": 6, "July": 7,
               "Energy ugust": 8, "September": 9, "October": 10, "November": 11, "December": 12}

year_month_production = Energy .groupby(by=["Source", "Year", "monthName"]).Production.sum().reset_index()
# sorting values based on the months
year_month_production = year_month_production.sort_values(by="monthName", key=lambda x: x.map({m: i for i, m in enumerate(month_order)}))

years = sorted(year_month_production.Year.unique())

plt.figure(figsize=(12, 18))
plt.subplot(4, 2, 8)

for i, year in enumerate(years):

    months = year_month_production[year_month_production.Year == year].monthName.unique()
    plt.subplot(4, 2, i*2 + 1)

    rule = lambda x: x[x.Year == year][x.Source == "Solar"]
    X_solar = rule(year_month_production).Production
    plt.pie(X_solar, labels=months, autopct='%1.1f%%')
    plt.title(f"{year} Solar Energy Production")

    plt.subplot(4, 2, i*2 + 2)

    rule = lambda x: x[x.Year == year][x.Source == "Wind"]
    X_wind = rule(year_month_production).Production
    plt.pie(X_wind, labels=months, autopct='%1.1f%%')
    plt.title(f"{year} Wind Energy Production")

plt.show()

"""3. Daily Energy Production"""

daily_production = Energy .groupby(by=["Source","Date"]).Production.sum().reset_index()
daily_production["Date"] = pd.to_datetime(daily_production["Date"])

sns.set_style("whitegrid")
plt.figure(figsize=(12, 9))

plt.subplot(2, 1, 2)

plt.subplot(2, 1, 1)
Color = ['red','green']
Col= ['black']
plt.title("Daily Wind Energy Production")
sns.lineplot(data=daily_production[daily_production.Source=="Wind"], x="Date", y="Production",palette = Color)
plt.xlabel("Date")
plt.ylabel("Production (MW)")

plt.subplot(2, 1, 2)
plt.title("Daily Solar Energy Production")
sns.lineplot(data=daily_production[daily_production.Source=="Solar"], x="Date", y="Production",palette = Col)
plt.xlabel("Date")
plt.ylabel("Production (MW)")

plt.show()

# encoding solar column
Energy .replace({'Source':{'Solar':1,'Wind':2}}, inplace=True)

3 # encoding 'monthName' column
Energy .replace({'monthName':{'January':0,'February':1,'March':2,'April':3,'May':4,'June':5,'July':6,'August':7,
                              'September':8,'October':9,'November':10,'December':11}}, inplace=True)
Energy

"""**Model Building**"""

# Splitting the data into training and testing sets
X = Energy[['Source','monthName','dayOfYear','Year']] # Features
y = Energy['Production']  # Target variable

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)



model = DecisionTreeRegressor()
model.fit(X_train, y_train)
model

predictions = model.predict(X_test)
predictions

mae = mean_absolute_error(y_test, predictions)
print('Mean Absolute Error:', mae)

from sklearn.metrics import r2_score
r2 = r2_score(y_test, predictions)
print('R-squared (R2) Score:', r2)

from sklearn.metrics import mean_squared_error

mse = mean_squared_error(y_test, predictions)
print('Mean Squared Error (MSE):', mse)

real_time_data = [[2,8,2,2035]]

# Predictions for real-time data
real_time_predictions = model.predict(real_time_data)
Solar = 1
Wind = 2
# Print the predictions
def energy_predictions():
      if real_time_data[0][0] == 1:
          print('Predicted Solar Energy Production for Real-Time Data:  ',real_time_predictions)
      elif real_time_data[0][0] == 2:
          print('Predicted Wind Energy Production for Real-Time Data:  ',real_time_predictions)
      else:
          print('Unknown Energy Source. Cannot provide predictions.')
energy_predictions()
# Indicate if there's less or more production
average_production = y_train.mean()  # Use the average production from the training data

for prediction in real_time_predictions:
    if prediction < average_production:
        print('Less production - Kindly Minimize the supply')

    elif prediction > average_production:
        print('More production - Store more for low production seasons.')

    else:
        print('Production is average - Balance the supply and storage')

# Adjust energy supply based on the area's production
# This part would involve actions specific to your application, such as controlling energy supply based on production levels.
# It depends on the context and what actions you need to take based on the predicted production levels.

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Calculate MAE, MSE, RMSE, and R2
mae = mean_absolute_error(y_test, predictions)
mse = mean_squared_error(y_test, predictions)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, predictions)

print('Mean Absolute Error (MAE):', mae)
print('Mean Squared Error (MSE):', mse)
print('Root Mean Squared Error (RMSE):', rmse)
print('R-squared (R2) Score:', r2)

from sklearn.ensemble import RandomForestRegressor

random_forest_model = RandomForestRegressor(random_state=42)
random_forest_model.fit(X_train, y_train)

# Predictions
predictions = random_forest_model.predict(X_test)

# Calculate evaluation metrics
rf_mae = mean_absolute_error(y_test, predictions)
rf_mse = mean_squared_error(y_test, predictions)
rf_rmse = np.sqrt(rf_mse)
rf_r2 = r2_score(y_test,predictions)

print('Random Forest Metrics:')
print('Mean Absolute Error (MAE):', rf_mae)
print('Mean Squared Error (MSE):', rf_mse)
print('Root Mean Squared Error (RMSE):', rf_rmse)
print('R-squared (R2) Score:', rf_r2)

import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Create and train the XGBoost model
xgb_model = xgb.XGBRegressor(objective ='reg:squarederror', random_state=42)  # for regression
xgb_model.fit(X_train, y_train)

# Predictions
xgb_predictions = xgb_model.predict(X_test)

# Calculate evaluation metrics
xgb_mae = mean_absolute_error(y_test, xgb_predictions)
xgb_mse = mean_squared_error(y_test, xgb_predictions)
xgb_rmse = np.sqrt(xgb_mse)
xgb_r2 = r2_score(y_test, xgb_predictions)

print('XGBoost Metrics:')
print('Mean Absolute Error (MAE):', xgb_mae)
print('Mean Squared Error (MSE):', xgb_mse)
print('Root Mean Squared Error (RMSE):', xgb_rmse)
print('R-squared (R2) Score:', xgb_r2)

import matplotlib.pyplot as plt

# Assuming you have the true labels (y_test) and predictions for each model

# Plot for Decision Tree
plt.figure(figsize=(10, 6))
plt.scatter(y_test, predictions, color='blue', label='Predictions (Decision Tree)')
plt.xlabel('True Values')
plt.ylabel('Predictions')
plt.title('True vs. Predicted Values for Decision Tree')
plt.legend()
plt.show()

# Plot for Random Forest
plt.figure(figsize=(10, 6))
plt.scatter(y_test, predictions, color='green', label='Predictions (Random Forest)')
plt.xlabel('True Values')
plt.ylabel('Predictions')
plt.title('True vs. Predicted Values for Random Forest')
plt.legend()
plt.show()

# Plot for XGBoost
plt.figure(figsize=(10, 6))
plt.scatter(y_test, xgb_predictions, color='red', label='Predictions (XGBoost)')
plt.xlabel('True Values')
plt.ylabel('Predictions')
plt.title('True vs. Predicted Values for XGBoost')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# Calculate MAE, MSE, RMSE, and R2 for each model
mae_scores = [mae, rf_mae, xgb_mae]
mse_scores = [mse, rf_mse, xgb_mse]
rmse_scores = [rmse, rf_rmse, xgb_rmse]
r2_scores = [r2, rf_r2, xgb_r2]

# Algorithms
algorithms = ['Decision Tree', 'Random Forest', 'XGBoost']

# Create subplots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 8))
fig.subplots_adjust(hspace=0.5)

# MAE comparison
axes[0, 0].bar(algorithms, mae_scores, color=['blue', 'green', 'red'])
axes[0, 0].set_title('Mean Absolute Error (MAE)')
axes[0, 0].set_ylabel('MAE')

# MSE comparison
axes[0, 1].bar(algorithms, mse_scores, color=['blue', 'green', 'red'])
axes[0, 1].set_title('Mean Squared Error (MSE)')
axes[0, 1].set_ylabel('MSE')

# RMSE comparison
axes[1, 0].bar(algorithms, rmse_scores, color=['blue', 'green', 'red'])
axes[1, 0].set_title('Root Mean Squared Error (RMSE)')
axes[1, 0].set_ylabel('RMSE')

# R2 comparison
axes[1, 1].bar(algorithms, r2_scores, color=['blue', 'green', 'red'])
axes[1, 1].set_title('R-squared (R2) Score')
axes[1, 1].set_ylabel('R2')

# Display the plot
plt.tight_layout()
plt.show()

with open('renewable_energy_model.pkl', 'wb') as model_file:
    pickle.dump(model, model_file)
with open('renewable_energy_model.pkl', 'rb') as model_file:
    model = pickle.load(model_file)
app = Flask(__name__)
@app.route('/')
def home():
    return "Welcome to Renewable Energy Optimization Portal🚀"


@app.route('/predict', methods=["POST"])
def predict():
    data = int(request.form.get())
    source = data['Source']
    month = data['monthName']
    day = data['dayOfYear']
    year = data['Year']

    # Ensure the input features are in the correct format for prediction
    input_features = [[source, month, day, year]]
    input_features = pd.DataFrame(input_features, columns=['Source', 'monthName', 'dayOfYear', 'Year'])

    p = model.predict(np.array(input_features))
    output = round(p)

    return jsonify({"energyProduced": output})


if __name__ == "__main__":
    app.run(debug=True)
